#!/bin/bash
linkLogPath="./Links.log"

useAprsIs=1 #set to 0 to not send to IS
aprsLogin=N0CALL-Z #DO NOT USE same login as repeater call i.e. if your repeater is N0CALL-B use e.g. N0CALL-Z
aprsPasscode=1234
aprsIsServer="rotate.aprs2.net:14580"

useAX25=0 #set to 0 to not send to AX25
ax25FromCall=N0CALL-1 #DO NOT put letters in the SSID
ax25DigiPath= #Set to WIDE2-1 etc, pultiple input shall be space separetd leave empty for no digipeateting
ax25Port=APRS #Name of the port configured in /etc/ax25/axports you want to use

#No user sericeable parts below
function parseLinkLine() {
	local linkLine="$1"
	local -n lorepeaterCall=$2
	local -n loreflector=$3

	local regex="[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}: (DCS|DExtra|DPlus){1} link - Type: (Repeater|Dongle) Rptr: ([0-9A-Z]{1,7}) {0,5}([A-Z]) Refl: ([0-9A-Z ]{1,7}[A-Z]) Dir: Outgoing"
	#2021-12-18 14:09:27: DPlus link - Type: Dongle Rptr: F5ZEE  C Refl: REF084 C Dir: Outgoing
	#2021-12-18 14:09:27: DCS link - Type: Repeater Rptr: F5ZEE  B Refl: DCS208 C Dir: Outgoing
	if [[ $linkLine =~ $regex ]]
	then
		lorepeaterCall="${BASH_REMATCH[3]}-${BASH_REMATCH[4]}"
		loreflector="${BASH_REMATCH[5]}"
		return 0
	fi
	return 1
}

function sendToAPRSIS() {
	
	local frame="$1>DSTAR:$2"
	echo $frame
	tmpscript=`cat /dev/urandom | tr -cd 'a-f0-9' | head -c 32`
	tmpscript="/tmp/"$tmpscript
	logintext="user $aprsLogin pass $aprsPasscode vers DStarLinkToAprsStatus 1.0"
	
	echo '#!/bin/bash' > $tmpscript
	echo "echo '$logintext'" >> $tmpscript
	echo "sleep 2" >> $tmpscript
	echo "echo '$frame'" >> $tmpscript
	chmod +x $tmpscript
	$tmpscript | socat - TCP:${aprsIsServer}
	rm -f $tmpscript	
}

function sendToAX25() {
	#make it a third party frame to accomodate for letters in SSID
	local frame="}$1>DSTAR,TCPIP,$ax25FromCall:$2"
	/usr/sbin/beacon -c $ax25FromCall -d "APRS $ax25DigiPath" -s $ax25Port "${frame}"
}

function sendStatus() {
	local repeaterCall=
	local reflector=
	readarray -t linkLines <<< "`cat $linkLogPath`"
	#declare -p linkLines

	for linkLine in "${linkLines[@]}"
	do
		parseLinkLine "${linkLine}" repeaterCall reflector
		parseOk=$?
		if [ "$parseOk" -eq 0 ]
		then
			statusFrame=">$repeaterCall linked to $reflector"
			if [ "$useAprsIs" -eq 1 ]
			then
				sendToAPRSIS "${repeaterCall}" "${statusFrame}"
			fi
			if [ "$useAX25" -eq 1 ]
			then
				sendToAX25 "${repeaterCall}" "${statusFrame}"
			fi
		fi
	done
}

function killBackgroundAndExit()
{
	exit 1
}

function main() {
	sendStatus
	inotifywait -q -m -e close_write $linkLogPath |
	while read -r filename event; do
		sendStatus
	done


	# while [ 1 ]
	# do
	# 	newFileContent=$($getLinkLogCommand)
	# 	if [[ "$prevFileContent" == "$snewFileContent" ]]
	# 	then
	# 		echo "No link change"
	# 	else
	# 		sendStatus
	# 		echo $prevFileContent
	# 		echo $newFileContent
	# 		prevFileContent=$newFileContent
	# 	fi

	# 	sleep 10
	# done
}

# trap killBackgroundAndExit HUP INT TERM
main